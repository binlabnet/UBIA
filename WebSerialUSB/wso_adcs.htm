<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="ina2.css">
    <title>Get ADC data</title>
  </head>
  <body>
    <div style="height: auto; width: auto; text-align: center;">
    <div id='div_v'>
	    <canvas id='scope'></canvas>
    </div>
		Window: <span id='wdsize'>?</span> sec, Sample Rate: <span id='smprate'>?</span> smps
	<div>
		<span id='labdiv'>?</span>
		<input type="button" id="butOpen" value="Open">
		<input type="button" id="butOnOff" value="Stop">
		<input type="button" id="butSave" value="Save data.csv"><br>
	</div>
	</div>
  </body>
<script type="text/javascript">
"use strict";
var $ = function(id) {
	return document.getElementById(id);
}
class SerialController {
    async init(init_cb) {
        if ('serial' in navigator) {
            try {
                this.port = await navigator.serial.requestPort();
                await this.port.open({baudRate: 115200, baudrate: 115200});
                this.writer = this.port.writable.getWriter();
				if (typeof init_cb == 'function') init_cb(this.port);
            }
            catch (err) {
                console.error('There was an error opening the serial port:', err);
            }
        }
        else {
            console.error('Web serial doesn\'t seem to be enabled in your browser. Try enabling it by visiting:');
            console.error('chrome://flags/#enable-experimental-web-platform-features');
            console.error('opera://flags/#enable-experimental-web-platform-features');
            console.error('edge://flags/#enable-experimental-web-platform-features');
            // chrome://device-log
        }
    }
    async write_raw(data) {
        return await this.writer.write(data);
    }
    async read_raw_all(add_data_cb) {
		try {
			//if(this.reader === undefined)
	        this.reader = this.port.readable.getReader();
			while (true) {
				const { value, done } = await this.reader.read();
				if (done) {
					// console.log('|reader| has been canceled.');
			        break;
				}
				// Do something with |value|...
				if (typeof add_data_cb == 'function') add_data_cb(value);
			}
		} catch (err) {
   	        console.error('Error reading data:', err);
		}
	}
    async close() {
		await this.writer.close();
		await this.reader.cancel();
		await this.port.close();
    }
}
var serialController = new SerialController();
const connect = $('butOpen');
function StartADC() {
	connect.value = 'Close';
	console.log('StopI2C...');
	serialController.write_raw(new Uint8Array([1, 1, 0])); // [1, 1, 0] // Stop I2C
 	serialController.read_raw_all(readnew);
}
connect.addEventListener('pointerdown', () => {
	if(connect.value == 'Close') {
		console.log('StopADC...');
		serialController.write_raw(new Uint8Array([1, 8, 0])); // [1, 8, 0] // Stop ADC
 		serialController.close();
		if(sttim != 0) {
			clearInterval(sitim);
			sttim = 0;
		}
		cur_idx = 0;
		old_idx = 0;
		smpsa = [];
		data_ch1 = [];
		frend = 0;
		blk = [];
		connect.value = 'Open';
	} else {
		serialController.init(StartADC);
	}
});
//**************************************
var smprate = 50000; // 500..50000 sps
const levelRisingEdge = 30000 // 32768
//**************************************
var smps = smprate;
var sttim = 0;
var sitim;
var cur_idx = 0;
var old_idx = 0;
var smpsa = [];
var frend = 0;
function wsSmpRate() {
	var idx = cur_idx, tt = new Date().getTime();
	var sps = (idx - old_idx) * 1000/ (tt - sttim);
	sttim = tt;	old_idx = idx;
	smpsa.push(sps);
	var len = smpsa.length;	
	if(len > 100) { smpsa.shift(); len-- };
	var csps = 0;
	for (var i = 0; i < len; i++) csps += smpsa[i];
	csps = csps/len;
	$('smprate').innerHTML = csps.toFixed(1);
  	$('labdiv').innerHTML = 'Render ' + frend + ' Hz';
  	frend = 0;
}
var rend = true;
$("butOnOff").onclick =  function() {
	if(rend) {rend = false; $("butOnOff").value = "Run";} 
	else {rend = true; $("butOnOff").value = "Stop";}
}
var data_ch1 = [];
var showData1 = [];
var ctx = $('scope').getContext('2d');

window.onresize = function(){    
	$('wdsize').innerHTML = ctx.canvas.width/smprate;
	ctx.canvas.width = (window.innerWidth-12)&(-2);
	ctx.canvas.height= (window.innerHeight-80)&(-2);
}	
window.onresize();
function draw() {
  let width = ctx.canvas.width;
  let height = ctx.canvas.height;
  let timeData1 = data_ch1;
  let scaling = height / 65536;
  let przdg = 0;
  let len = timeData1.length;

  ctx.fillStyle = 'rgba(0, 20, 0, 0.1)';
  ctx.fillRect(0, 0, width, height);


  ctx.beginPath();
  ctx.strokeStyle = 'rgb(0, 255, 0)';
  ctx.lineWidth = 1;
  ctx.setLineDash([]);

  if (timeData1.length > width*2) {
  	przdg = width/2;
	while (timeData1[przdg] > levelRisingEdge-1 && przdg <= timeData1.length - width/2) przdg++;
	while (timeData1[przdg] < levelRisingEdge+1 && przdg <= timeData1.length - width/2) przdg++;
	if (przdg >= timeData1.length - width/2) { // not przdg
		if(timeData1.length > width*4)
			data_ch1 = data_ch1.slice(width*2);
	} else if (przdg > 0) {
		showData1 = data_ch1.slice(przdg - width/2, przdg + width/2);
		data_ch1 = data_ch1.slice(przdg + width/2);
	}
  }
  for (let x = 0; x < showData1.length && x < width; x++)
	ctx.lineTo(x, height - showData1[x] * scaling);
  ctx.stroke();

  ctx.beginPath();
  ctx.lineWidth = 0.1;
  ctx.strokeStyle = 'rgb(155, 155, 155)';
  ctx.setLineDash([1, 1]);
  ctx.moveTo(0, height - levelRisingEdge * scaling);
  ctx.lineTo(width, height - levelRisingEdge * scaling);
  ctx.moveTo(width/2, 0);
  ctx.lineTo(width/2, height);
  ctx.stroke();
  frend++;
  requestAnimationFrame(draw);
}
draw();

var blk = new Uint8Array();

function concatTypedArrays(a, b) { // a, b TypedArray of same type
    let c = new (b.constructor)(a.length + b.length);
    c.set(a, 0);
    c.set(b, a.length);
    return c;
}
function readnew(data) {
	if(data instanceof Uint8Array) {
		blk = concatTypedArrays(blk, data);
		while(blk.length > 1) {
			let blksz = blk[0];
			if (blk.length < blksz + 2)	return;
			if (blk[1] == 0x0A) { // adc data
				if(!sttim) {
					sttim = new Date().getTime();
					sitim = setInterval(function(){wsSmpRate()}, 500);
				}
				for (var i=0; i<blksz; i+=2) {
					if(rend)
						data_ch1.push([blk[i+2] | (blk[i+3]<<8)]);
					cur_idx++;
				}
			} else {
				console.log(blk.slice(0,blksz+2));
				if(blk[1] == 0x01) { // response to the command stop i2c -> i2c config?
					// Next command: set cfg ADC, start ADC
					console.log('StartADC %.3f ksps...', smprate/1000);
					serialController.write_raw(new Uint8Array([6, 8, 100, 9, smprate&0xff, (smprate>>8)&0xff, 0, 0])); 
				}
			}
			blk = blk.slice(blksz+2);
		}
	} else console.log('data?', data);
}
function convertArrayOfObjectsToCSV(value){
	var result, ctr, keys, columnDelimiter, lineDelimiter, data;

	data = value.data || null;
	if (data == null || !data.length) {return null;}
	columnDelimiter = value.columnDelimiter || ';';
	lineDelimiter = value.lineDelimiter || '\n';
	keys = Object.keys(data[1]);
	result = '';
	result += keys.join(columnDelimiter);
	result += lineDelimiter;
	data.forEach(function(item){
		ctr = 0;
		keys.forEach(function(key){
			if (ctr > 0) 
				result += columnDelimiter;
			result += item[key];
			ctr++;
		});
		result += lineDelimiter;
	});
    return result;
} 
function download(data, filename, type) {
	let file = new Blob([data], {type: type});
	if (window.navigator.msSaveOrOpenBlob) { // ie10+
		window.navigator.msSaveOrOpenBlob(file, filename);
	} else { // ff, chrome
		let url = URL.createObjectURL(file);
		let a = document.createElement("a");
		a.href = url;
		a.download = filename;
		document.body.appendChild(a);
		a.click();
		setTimeout(function(){document.body.removeChild(a);window.URL.revokeObjectURL(url);},0);
		URL.revokeObjectURL(url);
	}
	//file.close();
}
$("butSave").onclick =  function() { 	
	let csv = convertArrayOfObjectsToCSV({data: showData1});
    download(csv, 'data.csv', 'text/csv;charset=utf-8');
}

</script>
</html>
